"Variable","Annotation","Modifier","Comment"
"[mBase]","[]","[]","Optional.empty"
"[mServiceHandler]","[]","[PRIVATE, VOLATILE]","Optional.empty"
"[mName]","[]","[PRIVATE]","Optional.empty"
"[mTouchPaddingScaledSq]","[]","[PRIVATE]","Optional.empty"
"[mContext]","[]","[PRIVATE, FINAL]","Optional.empty"
"[mWindowManager]","[]","[PRIVATE, FINAL]","Optional.empty"
"[mAutoDismissControls = true]","[]","[PRIVATE]","Optional.empty"
"[mOwnerView]","[]","[PRIVATE, FINAL]","Optional[/**
 * The view that is being zoomed by this zoom controller.
 */
]"
"[mOwnerViewRawLocation = new int[2]]","[]","[PRIVATE, FINAL]","Optional[/**
 * The location of the owner view on the screen. This is recalculated
 * each time the zoom controller is shown.
 */
]"
"[mContainer]","[]","[PRIVATE, FINAL]","Optional[/**
 * The container that is added as a window.
 */
]"
"[mContainerLayoutParams]","[]","[PRIVATE]","Optional.empty"
"[mContainerRawLocation = new int[2]]","[]","[PRIVATE, FINAL]","Optional.empty"
"[mControls]","[]","[PRIVATE]","Optional.empty"
"[mTouchTargetView]","[]","[PRIVATE]","Optional[/**
 * The view (or null) that should receive touch events. This will get set if
 * the touch down hits the container. It will be reset on the touch up.
 */
]"
"[mTouchTargetWindowLocation = new int[2]]","[]","[PRIVATE, FINAL]","Optional[/**
 * The {@link #mTouchTargetView}'s location in window, set on touch down.
 */
]"
"[mReleaseTouchListenerOnUp]","[]","[PRIVATE]","Optional[/**
 * If the zoom controller is dismissed but the user is still in a touch
 * interaction, we set this to true. This will ignore all touch events until
 * up/cancel, and then set the owner's touch listener to null.
 * <p>
 * Otherwise, the owner view would get mismatched events (i.e., touch move
 * even though it never got the touch down.)
 */
]"
"[mIsVisible]","[]","[PRIVATE]","Optional[/**
 * Whether the container has been added to the window manager.
 */
]"
"[mTempRect = new Rect()]","[]","[PRIVATE, FINAL]","Optional.empty"
"[mTempIntArray = new int[2]]","[]","[PRIVATE, FINAL]","Optional.empty"
"[mCallback]","[]","[PRIVATE]","Optional.empty"
"[mPostedVisibleInitializer]","[]","[PRIVATE]","Optional[/**
 * When showing the zoom, we add the view as a new window. However, there is
 * logic that needs to know the size of the zoom which is determined after
 * it's laid out. Therefore, we must post this logic onto the UI thread so
 * it will be exceuted AFTER the layout. This is the logic.
 */
]"
"[mConfigurationChangedFilter = new IntentFilter(Intent.ACTION_CONFIGURATION_CHANGED)]","[]","[PRIVATE, FINAL]","Optional.empty"
"[mConfigurationChangedReceiver = new BroadcastReceiver() {

    @Override
    public void onReceive(Context context, Intent intent) {
        if (!mIsVisible)
            return;
        mHandler.removeMessages(MSG_POST_CONFIGURATION_CHANGED);
        mHandler.sendEmptyMessage(MSG_POST_CONFIGURATION_CHANGED);
    }
}]","[]","[PRIVATE, FINAL]","Optional[/**
 * Needed to reposition the zoom controls after configuration changes.
 */
]"
"[MSG_POST_CONFIGURATION_CHANGED = 2]","[]","[PRIVATE, STATIC, FINAL]","Optional[/**
 * When configuration changes, this is called after the UI thread is idle.
 */
]"
"[MSG_DISMISS_ZOOM_CONTROLS = 3]","[]","[PRIVATE, STATIC, FINAL]","Optional[/**
 * Used to delay the zoom controller dismissal.
 */
]"
"[MSG_POST_SET_VISIBLE = 4]","[]","[PRIVATE, STATIC, FINAL]","Optional[/**
 * If setVisible(true) is called and the owner view's window token is null,
 * we delay the setVisible(true) call until it is not null.
 */
]"
"[mHandler = new Handler() {

    @Override
    public void handleMessage(Message msg) {
        switch(msg.what) {
            case MSG_POST_CONFIGURATION_CHANGED:
                onPostConfigurationChanged();
                break;
            case MSG_DISMISS_ZOOM_CONTROLS:
                setVisible(false);
                break;
            case MSG_POST_SET_VISIBLE:
                if (mOwnerView.getWindowToken() == null) {
                    // Doh, it is still null, just ignore the set visible call
                    Log.e(TAG, ""Cannot make the zoom controller visible if the owner view is "" + ""not attached to a window."");
                } else {
                    setVisible(true);
                }
                break;
        }
    }
}]","[]","[PRIVATE, FINAL]","Optional.empty"
"[ELLIPSIS_UNDEFINED = 0x80000000]","[]","[PRIVATE, STATIC, FINAL]","Optional.empty"
"[EVENT_ID = ""event_id""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The id of the event.
 * <P>Type: INTEGER</P>
 */
]"
"[ATTENDEE_NAME = ""attendeeName""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The name of the attendee.
 * <P>Type: STRING</P>
 */
]"
"[ATTENDEE_EMAIL = ""attendeeEmail""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The email address of the attendee.
 * <P>Type: STRING</P>
 */
]"
"[ATTENDEE_RELATIONSHIP = ""attendeeRelationship""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The relationship of the attendee to the user.
 * <P>Type: INTEGER (one of {@link #RELATIONSHIP_ATTENDEE}, ...}.
 */
]"
"[RELATIONSHIP_NONE = 0]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[RELATIONSHIP_ATTENDEE = 1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[RELATIONSHIP_ORGANIZER = 2]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[RELATIONSHIP_PERFORMER = 3]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[RELATIONSHIP_SPEAKER = 4]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ATTENDEE_TYPE = ""attendeeType""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The type of attendee.
 * <P>Type: Integer (one of {@link #TYPE_REQUIRED}, {@link #TYPE_OPTIONAL})
 */
]"
"[TYPE_NONE = 0]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[TYPE_REQUIRED = 1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[TYPE_OPTIONAL = 2]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ATTENDEE_STATUS = ""attendeeStatus""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The attendance status of the attendee.
 * <P>Type: Integer (one of {@link #ATTENDEE_STATUS_ACCEPTED}, ...}.
 */
]"
"[ATTENDEE_STATUS_NONE = 0]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ATTENDEE_STATUS_ACCEPTED = 1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ATTENDEE_STATUS_DECLINED = 2]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ATTENDEE_STATUS_INVITED = 3]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ATTENDEE_STATUS_TENTATIVE = 4]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CONTENT_URI = Uri.parse(""content://calendar/attendees"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CALENDAR_ID = ""calendar_id""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The calendar the event belongs to
 * <P>Type: INTEGER (foreign key to the Calendars table)</P>
 */
]"
"[HTML_URI = ""htmlUri""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The URI for an HTML version of this event.
 * <P>Type: TEXT</P>
 */
]"
"[TITLE = ""title""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The title of the event
 * <P>Type: TEXT</P>
 */
]"
"[DESCRIPTION = ""description""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The description of the event
 * <P>Type: TEXT</P>
 */
]"
"[EVENT_LOCATION = ""eventLocation""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Where the event takes place.
 * <P>Type: TEXT</P>
 */
]"
"[STATUS = ""eventStatus""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The event status
 * <P>Type: INTEGER (int)</P>
 */
]"
"[STATUS_TENTATIVE = 0]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[STATUS_CONFIRMED = 1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[STATUS_CANCELED = 2]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[SELF_ATTENDEE_STATUS = ""selfAttendeeStatus""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * This is a copy of the attendee status for the owner of this event.
 * This field is copied here so that we can efficiently filter out
 * events that are declined without having to look in the Attendees
 * table.
 *
 * <P>Type: INTEGER (int)</P>
 */
]"
"[COMMENTS_URI = ""commentsUri""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The comments feed uri.
 * <P>Type: TEXT</P>
 */
]"
"[DTSTART = ""dtstart""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The time the event starts
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[DTEND = ""dtend""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The time the event ends
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[DURATION = ""duration""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The duration of the event
 * <P>Type: TEXT (duration in RFC2445 format)</P>
 */
]"
"[EVENT_TIMEZONE = ""eventTimezone""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The timezone for the event.
 * <P>Type: TEXT
 */
]"
"[ALL_DAY = ""allDay""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Whether the event lasts all day or not
 * <P>Type: INTEGER (boolean)</P>
 */
]"
"[VISIBILITY = ""visibility""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Visibility for the event.
 * <P>Type: INTEGER</P>
 */
]"
"[VISIBILITY_DEFAULT = 0]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[VISIBILITY_CONFIDENTIAL = 1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[VISIBILITY_PRIVATE = 2]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[VISIBILITY_PUBLIC = 3]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[TRANSPARENCY = ""transparency""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Transparency for the event -- does the event consume time on the calendar?
 * <P>Type: INTEGER</P>
 */
]"
"[TRANSPARENCY_OPAQUE = 0]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[TRANSPARENCY_TRANSPARENT = 1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[HAS_ALARM = ""hasAlarm""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Whether the event has an alarm or not
 * <P>Type: INTEGER (boolean)</P>
 */
]"
"[HAS_EXTENDED_PROPERTIES = ""hasExtendedProperties""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Whether the event has extended properties or not
 * <P>Type: INTEGER (boolean)</P>
 */
]"
"[RRULE = ""rrule""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The recurrence rule for the event.
 * than one.
 * <P>Type: TEXT</P>
 */
]"
"[RDATE = ""rdate""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The recurrence dates for the event.
 * <P>Type: TEXT</P>
 */
]"
"[EXRULE = ""exrule""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The recurrence exception rule for the event.
 * <P>Type: TEXT</P>
 */
]"
"[EXDATE = ""exdate""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The recurrence exception dates for the event.
 * <P>Type: TEXT</P>
 */
]"
"[ORIGINAL_EVENT = ""originalEvent""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The _sync_id of the original recurring event for which this event is
 * an exception.
 * <P>Type: TEXT</P>
 */
]"
"[ORIGINAL_INSTANCE_TIME = ""originalInstanceTime""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The original instance time of the recurring event for which this
 * event is an exception.
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[ORIGINAL_ALL_DAY = ""originalAllDay""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The allDay status (true or false) of the original recurring event
 * for which this event is an exception.
 * <P>Type: INTEGER (boolean)</P>
 */
]"
"[LAST_DATE = ""lastDate""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The last date this event repeats on, or NULL if it never ends
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[FETCH_ENTRY_COLUMNS = new String[] { Events._SYNC_ACCOUNT, Events._SYNC_ID }]","[]","[PRIVATE, STATIC, FINAL]","Optional.empty"
"[ATTENDEES_COLUMNS = new String[] { AttendeesColumns.ATTENDEE_NAME, AttendeesColumns.ATTENDEE_EMAIL, AttendeesColumns.ATTENDEE_RELATIONSHIP, AttendeesColumns.ATTENDEE_TYPE, AttendeesColumns.ATTENDEE_STATUS }]","[]","[PRIVATE, STATIC, FINAL]","Optional.empty"
"[sCalendarClient = null]","[]","[PRIVATE, STATIC]","Optional.empty"
"[CONTENT_URI = Uri.parse(""content://calendar/events"")]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The content:// style URL for this table
 */
]"
"[DELETED_CONTENT_URI = Uri.parse(""content://calendar/deleted_events"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[DEFAULT_SORT_ORDER = """"]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The default sort order for this table
 */
]"
"[CONTENT_URI = Uri.parse(""content://calendar/instances/when"")]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The content:// style URL for this table
 */
]"
"[DEFAULT_SORT_ORDER = ""begin ASC""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The default sort order for this table.
 */
]"
"[SORT_CALENDAR_VIEW = ""begin ASC, end DESC, title ASC""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The sort order is: events with an earlier start time occur
 * first and if the start times are the same, then events with
 * a later end time occur first. The later end time is ordered
 * first so that long-running events in the calendar views appear
 * first.  If the start and end times of two events are
 * the same then we sort alphabetically on the title.  This isn't
 * required for correctness, it just adds a nice touch.
 */
]"
"[BEGIN = ""begin""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The beginning time of the instance, in UTC milliseconds
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[END = ""end""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The ending time of the instance, in UTC milliseconds
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[EVENT_ID = ""event_id""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The event for this instance
 * <P>Type: INTEGER (long, foreign key to the Events table)</P>
 */
]"
"[START_DAY = ""startDay""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The Julian start day of the instance, relative to the local timezone
 * <P>Type: INTEGER (int)</P>
 */
]"
"[END_DAY = ""endDay""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The Julian end day of the instance, relative to the local timezone
 * <P>Type: INTEGER (int)</P>
 */
]"
"[START_MINUTE = ""startMinute""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The start minute of the instance measured from midnight in the
 * local timezone.
 * <P>Type: INTEGER (int)</P>
 */
]"
"[END_MINUTE = ""endMinute""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The end minute of the instance measured from midnight in the
 * local timezone.
 * <P>Type: INTEGER (int)</P>
 */
]"
"[LOCAL_TIMEZONE = ""localTimezone""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The local timezone that was used for precomputing the fields
 * in the Instances table.
 */
]"
"[MIN_INSTANCE = ""minInstance""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The minimum time used in expanding the Instances table,
 * in UTC milliseconds.
 * <P>Type: INTEGER</P>
 */
]"
"[MAX_INSTANCE = ""maxInstance""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The maximum time used in expanding the Instances table,
 * in UTC milliseconds.
 * <P>Type: INTEGER</P>
 */
]"
"[MIN_BUSYBITS = ""minBusyBits""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The minimum Julian day in the BusyBits table.
 * <P>Type: INTEGER</P>
 */
]"
"[MAX_BUSYBITS = ""maxBusyBits""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The maximum Julian day in the BusyBits table.
 * <P>Type: INTEGER</P>
 */
]"
"[DAY = ""day""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The Julian day number.
 * <P>Type: INTEGER (int)</P>
 */
]"
"[BUSYBITS = ""busyBits""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The 24 bits representing the 24 1-hour time slots in a day.
 * If an event in the Instances table overlaps part of a 1-hour
 * time slot then the corresponding bit is set.  The first time slot
 * (12am to 1am) is bit 0.  The last time slot (11pm to midnight)
 * is bit 23.
 * <P>Type: INTEGER (int)</P>
 */
]"
"[ALL_DAY_COUNT = ""allDayCount""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The number of all-day events that occur on this day.
 * <P>Type: INTEGER (int)</P>
 */
]"
"[CONTENT_URI = Uri.parse(""content://calendar/busybits/when"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[PROJECTION = { DAY, BUSYBITS, ALL_DAY_COUNT }]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[MINUTES_PER_BUSY_INTERVAL = 60]","[]","[PUBLIC, STATIC, FINAL]","Optional[// The number of minutes represented by one busy bit
]"
"[INTERVALS_PER_DAY = 24 * 60 / MINUTES_PER_BUSY_INTERVAL]","[]","[PUBLIC, STATIC, FINAL]","Optional[// The number of intervals in a day
]"
"[EVENT_ID = ""event_id""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The event the reminder belongs to
 * <P>Type: INTEGER (foreign key to the Events table)</P>
 */
]"
"[MINUTES = ""minutes""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The minutes prior to the event that the alarm should ring.  -1
 * specifies that we should use the default value for the system.
 * <P>Type: INTEGER</P>
 */
]"
"[MINUTES_DEFAULT = -1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[METHOD = ""method""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The alarm method, as set on the server.  DEFAULT, ALERT, EMAIL, and
 * SMS are possible values; the device will only process DEFAULT and
 * ALERT reminders (the other types are simply stored so we can send the
 * same reminder info back to the server when we make changes).
 */
]"
"[METHOD_DEFAULT = 0]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[METHOD_ALERT = 1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[METHOD_EMAIL = 2]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[METHOD_SMS = 3]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[TABLE_NAME = ""Reminders""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CONTENT_URI = Uri.parse(""content://calendar/reminders"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[EVENT_ID = ""event_id""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The event that the alert belongs to
 * <P>Type: INTEGER (foreign key to the Events table)</P>
 */
]"
"[BEGIN = ""begin""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The start time of the event, in UTC
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[END = ""end""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The end time of the event, in UTC
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[ALARM_TIME = ""alarmTime""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The alarm time of the event, in UTC
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[CREATION_TIME = ""creationTime""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The creation time of this database entry, in UTC.
 * (Useful for debugging missed reminders.)
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[RECEIVED_TIME = ""receivedTime""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The time that the alarm broadcast was received by the Calendar app,
 * in UTC. (Useful for debugging missed reminders.)
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[NOTIFY_TIME = ""notifyTime""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The time that the notification was created by the Calendar app,
 * in UTC. (Useful for debugging missed reminders.)
 * <P>Type: INTEGER (long; millis since epoch)</P>
 */
]"
"[STATE = ""state""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The state of this alert.  It starts out as SCHEDULED, then when
 * the alarm goes off, it changes to FIRED, and then when the user
 * dismisses the alarm it changes to DISMISSED.
 * <P>Type: INTEGER</P>
 */
]"
"[SCHEDULED = 0]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[FIRED = 1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[DISMISSED = 2]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[MINUTES = ""minutes""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The number of minutes that this alarm precedes the start time
 * <P>Type: INTEGER </P>
 */
]"
"[DEFAULT_SORT_ORDER = ""alarmTime ASC,begin ASC,title ASC""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The default sort order for this table
 */
]"
"[TABLE_NAME = ""CalendarAlerts""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CONTENT_URI = Uri.parse(""content://calendar/calendar_alerts"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CONTENT_URI_BY_INSTANCE = Uri.parse(""content://calendar/calendar_alerts/by_instance"")]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * This URI is for grouping the query results by event_id and begin
 * time.  This will return one result per instance of an event.  So
 * events with multiple alarms will appear just once, but multiple
 * instances of a repeating event will show up multiple times.
 */
]"
"[EVENT_ID = ""event_id""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The event the extended property belongs to
 * <P>Type: INTEGER (foreign key to the Events table)</P>
 */
]"
"[NAME = ""name""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The name of the extended property.  This is a uri of the form
 * {scheme}#{local-name} convention.
 * <P>Type: TEXT</P>
 */
]"
"[VALUE = ""value""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The value of the extended property.
 * <P>Type: TEXT</P>
 */
]"
"[CONTENT_URI = Uri.parse(""content://calendar/extendedproperties"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[mLastSystemTime]","[]","[]","Optional[/**
 * The amount of system time loaded from the previous run.
 */
]"
"[mLastStarts]","[]","[]","Optional[/**
 * The number of times the process has started from the previous run.
 */
]"
"[mLastForegroundTime]","[]","[]","Optional[/**
 * The amount of foreground time loaded from the previous run
 */
]"
"[mUnpluggedUserTime]","[]","[]","Optional[/**
 * The amount of user time when last unplugged.
 */
]"
"[mUnpluggedSystemTime]","[]","[]","Optional[/**
 * The amount of system time when last unplugged.
 */
]"
"[mUnpluggedStarts]","[]","[]","Optional[/**
 * The number of times the process has started before unplugged.
 */
]"
"[mUnpluggedForegroundTime]","[]","[]","Optional[/**
 * The amount of foreground time since unplugged.
 */
]"
"[mWakeups]","[]","[]","Optional[/**
 * Number of times this package has done something that could wake up the
 * device from sleep.
 */
]"
"[mLoadedWakeups]","[]","[]","Optional[/**
 * Number of things that could wake up the device loaded from a
 * previous save.
 */
]"
"[mLastWakeups]","[]","[]","Optional[/**
 * Number of things that could wake up the device as of the
 * last run.
 */
]"
"[mUnpluggedWakeups]","[]","[]","Optional[/**
 * Number of things that could wake up the device as of the
 * last run.
 */
]"
"[mServiceStats = new HashMap<String, Serv>()]","[]","[FINAL]","Optional[/**
 * The statics we have collected for this package's services.
 */
]"
"[mStartTime]","[]","[]","Optional[/**
 * Total time (ms in battery uptime) the service has been left started.
 */
]"
"[mRunningSince]","[]","[]","Optional[/**
 * If service has been started and not yet stopped, this is
 * when it was started.
 */
]"
"[mRunning]","[]","[]","Optional[/**
 * True if we are currently running.
 */
]"
"[mStarts]","[]","[]","Optional[/**
 * Total number of times startService() has been called.
 */
]"
"[mLaunchedTime]","[]","[]","Optional[/**
 * Total time (ms in battery uptime) the service has been left launched.
 */
]"
"[mLaunchedSince]","[]","[]","Optional[/**
 * If service has been launched and not yet exited, this is
 * when it was launched (ms in battery uptime).
 */
]"
"[mLaunched]","[]","[]","Optional[/**
 * True if we are currently launched.
 */
]"
"[mLaunches]","[]","[]","Optional[/**
 * Total number times the service has been launched.
 */
]"
"[mLoadedStartTime]","[]","[]","Optional[/**
 * The amount of time spent started loaded from a previous save
 * (ms in battery uptime).
 */
]"
"[mLoadedStarts]","[]","[]","Optional[/**
 * The number of starts loaded from a previous save.
 */
]"
"[mLoadedLaunches]","[]","[]","Optional[/**
 * The number of launches loaded from a previous save.
 */
]"
"[mLastStartTime]","[]","[]","Optional[/**
 * The amount of time spent started as of the last run (ms
 * in battery uptime).
 */
]"
"[mLastStarts]","[]","[]","Optional[/**
 * The number of starts as of the last run.
 */
]"
"[mLastLaunches]","[]","[]","Optional[/**
 * The number of launches as of the last run.
 */
]"
"[mUnpluggedStartTime]","[]","[]","Optional[/**
 * The amount of time spent started when last unplugged (ms
 * in battery uptime).
 */
]"
"[mUnpluggedStarts]","[]","[]","Optional[/**
 * The number of starts when last unplugged.
 */
]"
"[mUnpluggedLaunches]","[]","[]","Optional[/**
 * The number of launches when last unplugged.
 */
]"
"[CREATOR = new Parcelable.Creator<BatteryStatsImpl>() {

    public BatteryStatsImpl createFromParcel(Parcel in) {
        return new BatteryStatsImpl(in);
    }

    public BatteryStatsImpl[] newArray(int size) {
        return new BatteryStatsImpl[size];
    }
}]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[_DATA = ""_data""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The location(on filesystem) of the binary data of the part.
 * <P>Type: INTEGER</P>
 */
]"
"[CONTENT_URI = Uri.withAppendedPath(Mms.CONTENT_URI, ""rate"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[SENT_TIME = ""sent_time""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * When a message was successfully sent.
 * <P>Type: INTEGER</P>
 */
]"
"[EXTRA_CONTENTS = ""contents""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The extra field to store the contents of the Intent,
 * which should be an array of Uri.
 */
]"
"[EXTRA_TYPES = ""types""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The extra field to store the type of the contents,
 * which should be an array of String.
 */
]"
"[EXTRA_CC = ""cc""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The extra field to store the 'Cc' addresses.
 */
]"
"[EXTRA_BCC = ""bcc""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The extra field to store the 'Bcc' addresses;
 */
]"
"[EXTRA_SUBJECT = ""subject""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The extra field to store the 'Subject'.
 */
]"
"[CONTENT_CHANGED_ACTION = ""android.intent.action.CONTENT_CHANGED""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Indicates that the contents of specified URIs were changed.
 * The application which is showing or caching these contents
 * should be updated.
 */
]"
"[DELETED_CONTENTS = ""deleted_contents""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * An extra field which stores the URI of deleted contents.
 */
]"
"[TYPE_DISCRIMINATOR_COLUMN = ""transport_type""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The column to distinguish SMS &amp; MMS messages in query results.
 */
]"
"[CONTENT_URI = Uri.parse(""content://mms-sms/"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CONTENT_CONVERSATIONS_URI = Uri.parse(""content://mms-sms/conversations"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CONTENT_FILTER_BYPHONE_URI = Uri.parse(""content://mms-sms/messages/byphone"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CONTENT_UNDELIVERED_URI = Uri.parse(""content://mms-sms/undelivered"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CONTENT_DRAFT_URI = Uri.parse(""content://mms-sms/draft"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[SMS_PROTO = 0]","[]","[PUBLIC, STATIC, FINAL]","Optional[// Constants for message protocol types.
]"
"[MMS_PROTO = 1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[NO_ERROR = 0]","[]","[PUBLIC, STATIC, FINAL]","Optional[// Constants for error types of pending messages.
]"
"[ERR_TYPE_GENERIC = 1]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ERR_TYPE_SMS_PROTO_TRANSIENT = 2]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ERR_TYPE_MMS_PROTO_TRANSIENT = 3]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ERR_TYPE_TRANSPORT_FAILURE = 4]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ERR_TYPE_GENERIC_PERMANENT = 10]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ERR_TYPE_SMS_PROTO_PERMANENT = 11]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ERR_TYPE_MMS_PROTO_PERMANENT = 12]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CONTENT_URI = Uri.withAppendedPath(MmsSms.CONTENT_URI, ""pending"")]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[PROTO_TYPE = ""proto_type""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The type of transport protocol(MMS or SMS).
 * <P>Type: INTEGER</P>
 */
]"
"[MSG_ID = ""msg_id""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The ID of the message to be sent or downloaded.
 * <P>Type: INTEGER</P>
 */
]"
"[MSG_TYPE = ""msg_type""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The type of the message to be sent or downloaded.
 * This field is only valid for MM. For SM, its value is always
 * set to 0.
 */
]"
"[ERROR_TYPE = ""err_type""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The type of the error code.
 * <P>Type: INTEGER</P>
 */
]"
"[ERROR_CODE = ""err_code""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The error code of sending/retrieving process.
 * <P>Type:  INTEGER</P>
 */
]"
"[RETRY_INDEX = ""retry_index""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * How many times we tried to send or download the message.
 * <P>Type:  INTEGER</P>
 */
]"
"[DUE_TIME = ""due_time""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The time to do next retry.
 */
]"
"[LAST_TRY = ""last_try""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The time we last tried to send or download the message.
 */
]"
"[CONTENT_URI = Uri.parse(""content://telephony/carriers"")]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The content:// style URL for this table
 */
]"
"[DEFAULT_SORT_ORDER = ""name ASC""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The default sort order for this table
 */
]"
"[NAME = ""name""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[APN = ""apn""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[PROXY = ""proxy""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[PORT = ""port""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[MMSPROXY = ""mmsproxy""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[MMSPORT = ""mmsport""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[SERVER = ""server""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[USER = ""user""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[PASSWORD = ""password""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[MMSC = ""mmsc""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[MCC = ""mcc""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[MNC = ""mnc""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[NUMERIC = ""numeric""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[TYPE = ""type""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CURRENT = ""current""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[SECRET_CODE_ACTION = ""android.provider.Telephony.SECRET_CODE""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Broadcast Action: A ""secret code"" has been entered in the dialer. Secret codes are
 * of the form *#*#<code>#*#*. The intent will have the data URI:</p>
 *
 * <p><code>android_secret_code://&lt;code&gt;</code></p>
 */
]"
"[SPN_STRINGS_UPDATED_ACTION = ""android.provider.Telephony.SPN_STRINGS_UPDATED""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Broadcast Action: The Service Provider string(s) have been updated.  Activities or
 * services that use these strings should update their display.
 * The intent will have the following extra values:</p>
 * <ul>
 * <li><em>showPlmn</em> - Boolean that indicates whether the PLMN should be shown.</li>
 * <li><em>plmn</em> - The operator name of the registered network, as a string.</li>
 * <li><em>showSpn</em> - Boolean that indicates whether the SPN should be shown.</li>
 * <li><em>spn</em> - The service provider name, as a string.</li>
 * </ul>
 * Note that <em>showPlmn</em> may indicate that <em>plmn</em> should be displayed, even
 * though the value for <em>plmn</em> is null.  This can happen, for example, if the phone
 * has not registered to a network yet.  In this case the receiver may substitute an
 * appropriate placeholder string (eg, ""No service"").
 *
 * It is recommended to display <em>plmn</em> before / above <em>spn</em> if
 * both are displayed.
 *
 * <p>Note this is a protected intent that can only be sent
 * by the system.
 */
]"
"[EXTRA_SHOW_PLMN = ""showPlmn""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[EXTRA_PLMN = ""plmn""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[EXTRA_SHOW_SPN = ""showSpn""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[EXTRA_SPN = ""spn""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[CONTENT_TYPE = ""vnd.android-dir/im-sessionCookies""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The MIME type of {@link #CONTENT_URI} providing a directory of
 * people.
 */
]"
"[PROVIDER = ""provider""]","[]","[]","Optional[/**
 * The id in database of the related provider
 *
 * <P>Type: INT</P>
 */
]"
"[NAME = ""name""]","[]","[]","Optional[/**
 * The name of the setting
 * <P>Type: TEXT</P>
 */
]"
"[VALUE = ""value""]","[]","[]","Optional[/**
 * The value of the setting
 * <P>Type: TEXT</P>
 */
]"
"[CONTENT_URI = Uri.parse(""content://im/providerSettings"")]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The content:// style URI for this table
 */
]"
"[CONTENT_TYPE = ""vnd.android-dir/im-providerSettings""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The MIME type of {@link #CONTENT_URI} providing provider settings
 */
]"
"[SHOW_OFFLINE_CONTACTS = ""show_offline_contacts""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * A boolean value to indicate whether this provider should show the offline contacts
 */
]"
"[SETTING_AUTOMATICALLY_CONNECT_GTALK = ""gtalk_auto_connect""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * controls whether or not the GTalk service automatically connect to server.
 */
]"
"[SETTING_AUTOMATICALLY_START_SERVICE = ""auto_start_service""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * controls whether or not the IM service will be automatically started after boot
 */
]"
"[SETTING_HIDE_OFFLINE_CONTACTS = ""hide_offline_contacts""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * controls whether or not the offline contacts will be hided
 */
]"
"[SETTING_ENABLE_NOTIFICATION = ""enable_notification""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * controls whether or not enable the IM notification
 */
]"
"[SETTING_VIBRATE = ""vibrate""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * specifies whether or not to vibrate
 */
]"
"[SETTING_RINGTONE = ""ringtone""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * specifies the Uri string of the ringtone
 */
]"
"[SETTING_RINGTONE_DEFAULT = ""content://settings/system/notification_sound""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * specifies the Uri of the default ringtone
 */
]"
"[SETTING_SHOW_MOBILE_INDICATOR = ""mobile_indicator""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * specifies whether or not to show mobile indicator to friends
 */
]"
"[LAST_RMQ_RECEIVED = ""last_rmq_rec""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Used for reliable message queue (RMQ). This is for storing the last rmq id received
 * from the GTalk server
 */
]"
"[mContentResolver]","[]","[PRIVATE]","Optional.empty"
"[mProviderId]","[]","[PRIVATE]","Optional.empty"
"[RMQ_ID = ""rmq_id""]","[]","[]","Optional.empty"
"[TYPE = ""type""]","[]","[]","Optional.empty"
"[TIMESTAMP = ""ts""]","[]","[]","Optional.empty"
"[DATA = ""data""]","[]","[]","Optional.empty"
"[RMQ_ID_PROJECTION = new String[] { RMQ_ID }]","[]","[PRIVATE, STATIC]","Optional.empty"
"[CONTENT_URI = Uri.parse(""content://im/outgoingRmqMessages"")]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The content:// style URL for this table.
 */
]"
"[CONTENT_URI_FOR_HIGHEST_RMQ_ID = Uri.parse(""content://im/outgoingHighestRmqId"")]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The content:// style URL for the highest rmq id for the outgoing rmq messages
 */
]"
"[DEFAULT_SORT_ORDER = ""rmq_id ASC""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The default sort order for this table.
 */
]"
"[RMQ_ID = ""rmq_id""]","[]","[]","Optional.empty"
"[PROJECTION = new String[] { RMQ_ID }]","[]","[PRIVATE, STATIC]","Optional.empty"
"[CONTENT_URI = Uri.parse(""content://im/lastRmqId"")]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The content:// style URL for this table.
 */
]"
"[PROVIDER_ID = ""provider_id""]","[]","[]","Optional[/**
 * The provider ID
 * <P>Type: INTEGER</P>
 */
]"
"[APP_RES_ID = ""app_res_id""]","[]","[]","Optional[/**
 * The application resource ID
 * <P>Type: INTEGER</P>
 */
]"
"[PLUGIN_RES_ID = ""plugin_res_id""]","[]","[]","Optional[/**
 * The plugin resource ID
 * <P>Type: INTEGER</P>
 */
]"
"[CONTENT_URI = Uri.parse(""content://im/brandingResMapCache"")]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The content:// style URL for this table.
 */
]"
"[GTALK_SERVICE_MAX_RECONNECT_DELAY = ""gtalk_max_reconnect_delay""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The maximum reconnect delay time, in milliseconds.
 */
]"
"[GTALK_SERVICE_SHORT_NETWORK_DOWNTIME = ""gtalk_short_network_downtime""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The network downtime that is considered ""short"" for the above calculations,
 * in milliseconds.
 */
]"
"[GTALK_SERVICE_AWAY_HEARTBEAT_INTERVAL_MS = // keep the string backward compatible
""gtalk_heartbeat_ping_interval_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * How frequently we send heartbeat pings to the GTalk server. Receiving a server packet
 * will reset the heartbeat timer. The away heartbeat should be used when the user is
 * logged into the GTalk app, but not actively using it.
 */
]"
"[GTALK_SERVICE_ACTIVE_HEARTBEAT_INTERVAL_MS = ""gtalk_active_heartbeat_ping_interval_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * How frequently we send heartbeat pings to the GTalk server. Receiving a server packet
 * will reset the heartbeat timer. The active heartbeat should be used when the user is
 * actively using the GTalk app.
 */
]"
"[GTALK_SERVICE_SYNC_HEARTBEAT_INTERVAL_MS = ""gtalk_sync_heartbeat_ping_interval_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * How frequently we send heartbeat pings to the GTalk server. Receiving a server packet
 * will reset the heartbeat timer. The sync heartbeat should be used when the user isn't
 * logged into the GTalk app, but auto-sync is enabled.
 */
]"
"[GTALK_SERVICE_NOSYNC_HEARTBEAT_INTERVAL_MS = ""gtalk_nosync_heartbeat_ping_interval_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * How frequently we send heartbeat pings to the GTalk server. Receiving a server packet
 * will reset the heartbeat timer. The no sync heartbeat should be used when the user isn't
 * logged into the GTalk app, and auto-sync is not enabled.
 */
]"
"[GTALK_SERVICE_HEARTBEAT_ACK_TIMEOUT_MS = ""gtalk_heartbeat_ack_timeout_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * How long we wait to receive a heartbeat ping acknowledgement (or another packet)
 * from the GTalk server, before deeming the connection dead.
 */
]"
"[GTALK_SERVICE_IDLE_TIMEOUT_MS = ""gtalk_idle_timeout_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * How long after screen is turned off before we consider the user to be idle.
 */
]"
"[GTALK_SERVICE_CONNECT_ON_AUTO_SYNC = ""gtalk_connect_on_auto_sync""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * By default, GTalkService will always connect to the server regardless of the auto-sync
 * setting. However, if this parameter is true, then GTalkService will only connect
 * if auto-sync is enabled. Using the GTalk app will trigger the connection too.
 */
]"
"[GTALK_DATA_MESSAGE_WAKELOCK_MS = ""gtalk_data_message_wakelock_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * GTalkService holds a wakelock while broadcasting the intent for data message received.
 * It then automatically release the wakelock after a timeout. This setting controls what
 * the timeout should be.
 */
]"
"[GTALK_SSL_HANDSHAKE_TIMEOUT_MS = ""gtalk_ssl_handshake_timeout_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The socket read timeout used to control how long ssl handshake wait for reads before
 * timing out. This is needed so the ssl handshake doesn't hang for a long time in some
 * circumstances.
 */
]"
"[GTALK_COMPRESS = ""gtalk_compress""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Compress the gtalk stream.
 */
]"
"[GTALK_USE_BARE_JID_TIMEOUT_MS = ""gtalk_use_barejid_timeout_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * This is the timeout for which Google Talk will send the message using bareJID. In a
 * established chat between two XMPP endpoints, Google Talk uses fullJID in the format
 * of user@domain/resource in order to send the message to the specific client. However,
 * if Google Talk hasn't received a message from that client after some time, it would
 * fall back to use the bareJID, which would broadcast the message to all clients for
 * the other user.
 */
]"
"[SSL_SESSION_CACHE = ""ssl_session_cache""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Enable use of ssl session caching.
 * 'db' - save each session in a (per process) database
 * 'file' - save each session in a (per process) file
 * not set or any other value - normal java in-memory caching
 */
]"
"[SYNC_MIN_GZIP_BYTES = ""sync_min_gzip_bytes""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * How many bytes long a message has to be, in order to be gzipped.
 */
]"
"[PROVISIONING_DIGEST = ""digest""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The hash value of the current provisioning settings
 */
]"
"[PROVISIONING_OVERRIDE = ""override""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Provisioning keys to block from server update
 */
]"
"[GOOGLE_LOGIN_GENERIC_AUTH_SERVICE = ""google_login_generic_auth_service""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * ""Generic"" service name for  authentication requests.
 */
]"
"[VENDING_SYNC_FREQUENCY_MS = ""vending_sync_frequency_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Frequency in milliseconds at which we should sync the locally installed Vending Machine
 * content with the server.
 */
]"
"[VENDING_SUPPORT_URL = ""vending_support_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Support URL that is opened in a browser when user clicks on 'Help and Info' in Vending
 * Machine.
 */
]"
"[VENDING_REQUIRE_SIM_FOR_PURCHASE = ""vending_require_sim_for_purchase""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Indicates if Vending Machine requires a SIM to be in the phone to allow a purchase.
 *
 * true = SIM is required
 * false = SIM is not required
 */
]"
"[VENDING_TOS_VERSION = ""vending_tos_version""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The current version id of the Vending Machine terms of service.
 */
]"
"[VENDING_TOS_URL = ""vending_tos_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * URL that points to the terms of service for Vending Machine.
 */
]"
"[VENDING_TOS_MISSING_URL = ""vending_tos_missing_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * URL to navigate to in browser (not Market) when the terms of service
 * for Vending Machine could not be accessed due to bad network
 * connection.
 */
]"
"[VENDING_USE_CHECKOUT_QA_SERVICE = ""vending_use_checkout_qa_service""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Whether to use sierraqa instead of sierra tokens for the purchase flow in
 * Vending Machine.
 *
 * true = use sierraqa
 * false = use sierra (default)
 */
]"
"[VENDING_DEFAULT_FILTER = ""vending_default_filter""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Default value to use for all/free/priced filter in Market.
 * Valid values: ALL, FREE, PAID (case insensitive)
 */
]"
"[VENDING_TAB_1_RANKING_TYPE = ""vending_tab_1_ranking_type""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Ranking type value to use for the first category tab (currently popular)
 */
]"
"[VENDING_TAB_1_TITLE = ""vending_tab_1_title""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Title string to use for first category tab.
 */
]"
"[VENDING_TAB_2_RANKING_TYPE = ""vending_tab_2_ranking_type""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Ranking type value to use for the second category tab (currently newest)
 */
]"
"[VENDING_TAB_2_TITLE = ""vending_tab_2_title""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Title string to use for second category tab.
 */
]"
"[VENDING_HEARTBEAT_FREQUENCY_MS = ""vending_heartbeat_frequency_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Frequency in milliseconds at which we should request MCS heartbeats
 * from the Vending Machine client.
 */
]"
"[VENDING_PENDING_DOWNLOAD_RESEND_FREQUENCY_MS = ""vending_pd_resend_frequency_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Frequency in milliseconds at which we should resend pending download
 * requests to the API Server from the Vending Machine client.
 */
]"
"[VENDING_DISK_INPUT_BUFFER_BYTES = ""vending_disk_input_buffer_bytes""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Size of buffer in bytes for Vending to use when reading cache files.
 */
]"
"[VENDING_DISK_OUTPUT_BUFFER_BYTES = ""vending_disk_output_buffer_bytes""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Size of buffer in bytes for Vending to use when writing cache files.
 */
]"
"[VENDING_PROMO_REFRESH_FREQUENCY_MS = ""vending_promo_refresh_freq_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Frequency in milliseconds at which we should cycle through the promoted applications
 * on the home screen or the categories page.
 */
]"
"[SETTINGS_TOS_URL = ""settings_tos_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * URL that points to the legal terms of service to display in Settings.
 * <p>
 * This should be a https URL. For a pretty user-friendly URL, use
 * {@link #SETTINGS_TOS_PRETTY_URL}.
 */
]"
"[SETTINGS_TOS_PRETTY_URL = ""settings_tos_pretty_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * URL that points to the legal terms of service to display in Settings.
 * <p>
 * This should be a pretty http URL. For the URL the device will access
 * via Settings, use {@link #SETTINGS_TOS_URL}.
 */
]"
"[SETTINGS_CONTRIBUTORS_URL = ""settings_contributors_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * URL that points to the contributors to display in Settings.
 * <p>
 * This should be a https URL. For a pretty user-friendly URL, use
 * {@link #SETTINGS_CONTRIBUTORS_PRETTY_URL}.
 */
]"
"[SETTINGS_CONTRIBUTORS_PRETTY_URL = ""settings_contributors_pretty_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * URL that points to the contributors to display in Settings.
 * <p>
 * This should be a pretty http URL. For the URL the device will access
 * via Settings, use {@link #SETTINGS_CONTRIBUTORS_URL}.
 */
]"
"[SETUP_GOOGLE_TOS_URL = ""setup_google_tos_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * URL that points to the Terms Of Service for the device.
 * <p>
 * This should be a pretty http URL.
 */
]"
"[SETUP_ANDROID_PRIVACY_URL = ""setup_android_privacy_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * URL that points to the Android privacy policy for the device.
 * <p>
 * This should be a pretty http URL.
 */
]"
"[SETUP_GOOGLE_PRIVACY_URL = ""setup_google_privacy_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * URL that points to the Google privacy policy for the device.
 * <p>
 * This should be a pretty http URL.
 */
]"
"[USE_MSISDN_TOKEN = ""use_msisdn_token""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Request an MSISDN token for various Google services.
 */
]"
"[GLS_PUBLIC_KEY = ""google_login_public_key""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * RSA public key used to encrypt passwords stored in the database.
 */
]"
"[PARENTAL_CONTROL_CHECK_ENABLED = ""parental_control_check_enabled""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Only check parental control status if this is set to ""true"".
 */
]"
"[PARENTAL_CONTROL_APPS_LIST = ""parental_control_apps_list""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The list of applications we need to block if parental control is
 * enabled.
 */
]"
"[PARENTAL_CONTROL_TIMEOUT_IN_MS = ""parental_control_timeout_in_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Duration in which parental control status is valid.
 */
]"
"[PARENTAL_CONTROL_EXPECTED_RESPONSE = ""parental_control_expected_response""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * When parental control is off, we expect to get this string from the
 * litmus url.
 */
]"
"[PARENTAL_CONTROL_REDIRECT_REGEX = ""parental_control_redirect_regex""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * When the litmus url returns a 302, declare parental control to be on
 * only if the redirect url matches this regular expression.
 */
]"
"[DISK_FREE_CHANGE_REPORTING_THRESHOLD = ""disk_free_change_reporting_threshold""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Threshold for the amount of change in disk free space required to report the amount of
 * free space. Used to prevent spamming the logs when the disk free space isn't changing
 * frequently.
 */
]"
"[GOOGLE_SERVICES_PREFIX = ""google_services:""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Prefix for new Google services published by the checkin
 * server.
 */
]"
"[SYNC_MAX_RETRY_DELAY_IN_SECONDS = ""sync_max_retry_delay_in_seconds""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The maximum reconnect delay for short network outages or when the network is suspended
 * due to phone use.
 */
]"
"[SYS_STORAGE_THRESHOLD_PERCENTAGE = ""sys_storage_threshold_percentage""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Minimum percentage of free storage on the device that is used to determine if
 * the device is running low on storage.
 * Say this value is set to 10, the device is considered running low on storage
 * if 90% or more of the device storage is filled up.
 */
]"
"[SYS_FREE_STORAGE_LOG_INTERVAL = ""sys_free_storage_log_interval""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The interval in minutes after which the amount of free storage left on the
 * device is logged to the event log
 */
]"
"[SMS_OUTGOING_CHECK_INTERVAL_MS = ""sms_outgoing_check_interval_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The interval in milliseconds at which to check the number of SMS sent
 * out without asking for use permit, to limit the un-authorized SMS
 * usage.
 */
]"
"[SMS_OUTGOING_CEHCK_MAX_COUNT = ""sms_outgoing_check_max_count""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The number of outgoing SMS sent without asking for user permit
 * (of {@link #SMS_OUTGOING_CHECK_INTERVAL_MS}
 */
]"
"[PDP_WATCHDOG_POLL_INTERVAL_MS = ""pdp_watchdog_poll_interval_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The interval in milliseconds at which to check packet counts on the
 * mobile data interface when screen is on, to detect possible data
 * connection problems.
 */
]"
"[PDP_WATCHDOG_LONG_POLL_INTERVAL_MS = ""pdp_watchdog_long_poll_interval_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The interval in milliseconds at which to check packet counts on the
 * mobile data interface when screen is off, to detect possible data
 * connection problems.
 */
]"
"[PDP_WATCHDOG_ERROR_POLL_INTERVAL_MS = ""pdp_watchdog_error_poll_interval_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The interval in milliseconds at which to check packet counts on the
 * mobile data interface after {@link #PDP_WATCHDOG_TRIGGER_PACKET_COUNT}
 * outgoing packets has been reached without incoming packets.
 */
]"
"[PDP_WATCHDOG_TRIGGER_PACKET_COUNT = ""pdp_watchdog_trigger_packet_count""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The number of outgoing packets sent without seeing an incoming packet
 * that triggers a countdown (of {@link #PDP_WATCHDOG_ERROR_POLL_COUNT}
 * device is logged to the event log
 */
]"
"[PDP_WATCHDOG_ERROR_POLL_COUNT = ""pdp_watchdog_error_poll_count""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The number of polls to perform (at {@link #PDP_WATCHDOG_ERROR_POLL_INTERVAL_MS})
 * after hitting {@link #PDP_WATCHDOG_TRIGGER_PACKET_COUNT} before
 * attempting data connection recovery.
 */
]"
"[PDP_WATCHDOG_MAX_PDP_RESET_FAIL_COUNT = ""pdp_watchdog_max_pdp_reset_fail_count""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The number of failed PDP reset attempts before moving to something more
 * drastic: re-registering to the network.
 */
]"
"[PDP_WATCHDOG_PING_ADDRESS = ""pdp_watchdog_ping_address""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Address to ping as a last sanity check before attempting any recovery.
 * Unset or set to ""0.0.0.0"" to skip this check.
 */
]"
"[PDP_WATCHDOG_PING_DEADLINE = ""pdp_watchdog_ping_deadline""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The ""-w deadline"" parameter for the ping, ie, the max time in
 * seconds to spend pinging.
 */
]"
"[GPRS_REGISTER_CHECK_PERIOD_MS = ""gprs_register_check_period_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The interval in milliseconds at which to check gprs registration
 * after the first registration mismatch of gprs and voice service,
 * to detect possible data network registration problems.
 */
]"
"[WIFI_IDLE_MS = ""wifi_idle_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The interval in milliseconds after which Wi-Fi is considered idle.
 * When idle, it is possible for the device to be switched from Wi-Fi to
 * the mobile data network.
 */
]"
"[SHORT_KEYLIGHT_DELAY_MS = ""short_keylight_delay_ms""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Screen timeout in milliseconds corresponding to the
 * PowerManager's POKE_LOCK_SHORT_TIMEOUT flag (i.e. the fastest
 * possible screen timeout behavior.)
 */
]"
"[VOICE_SEARCH_URL = ""voice_search_url""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * URL that points to the voice search servers. To be factored out of this class.
 */
]"
"[VOICE_SEARCH_ENCODING_THREE_G = ""voice_search_encoding_three_g""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Speech encoding used with voice search on 3G networks. To be factored out of this class.
 */
]"
"[VOICE_SEARCH_ENCODING_WIFI = ""voice_search_encoding_wifi""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Speech encoding used with voice search on WIFI networks. To be factored out of this class.
 */
]"
"[VOICE_SEARCH_ENABLE_AGC = ""voice_search_enable_agc""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Whether to use automatic gain control in voice search (0 = disable, 1 = enable).
 * To be factored out of this class.
 */
]"
"[VOICE_SEARCH_ENABLE_NS = ""voice_search_enable_ns""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Whether to use noise suppression in voice search (0 = disable, 1 = enable).
 * To be factored out of this class.
 */
]"
"[VOICE_SEARCH_ENABLE_IIR = ""voice_search_enable_iir""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Whether to use the IIR filter in voice search (0 = disable, 1 = enable).
 * To be factored out of this class.
 */
]"
"[AUTOTEST_SUITES_FILE = ""autotest_suites_file""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * List of test suites (local disk filename) for the automatic instrumentation test runner.
 * The file format is similar to automated_suites.xml, see AutoTesterService.
 * If this setting is missing or empty, the automatic test runner will not start.
 */
]"
"[AUTOTEST_CHECKIN_SECONDS = ""autotest_checkin_seconds""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Interval between synchronous checkins forced by the automatic test runner.
 * If you set this to a value smaller than CHECKIN_INTERVAL, then the test runner's
 * frequent checkins will prevent asynchronous background checkins from interfering
 * with any performance measurements.
 */
]"
"[AUTOTEST_REBOOT_SECONDS = ""autotest_reboot_seconds""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Interval between reboots forced by the automatic test runner.
 */
]"
"[BATTERY_DISCHARGE_DURATION_THRESHOLD = ""battery_discharge_duration_threshold""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Threshold values for the duration and level of a discharge cycle, under
 * which we log discharge cycle info.
 */
]"
"[BATTERY_DISCHARGE_THRESHOLD = ""battery_discharge_threshold""]","[]","[PUBLIC, STATIC, FINAL]","Optional.empty"
"[ANR_BUGREPORT_RECIPIENT = ""anr_bugreport_recipient""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * An email address that anr bugreports should be sent to.
 */
]"
"[USE_LOCATION_FOR_SERVICES = ""use_location""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Flag for allowing service provider to use location information to improve products and
 * services.
 * Type: int ( 0 = disallow, 1 = allow )
 * @deprecated
 */
]"
"[TAG = ""Bookmarks""]","[]","[PRIVATE, STATIC, FINAL]","Optional.empty"
"[CONTENT_URI = Uri.parse(""content://"" + AUTHORITY + ""/bookmarks"")]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The content:// style URL for this table
 */
]"
"[ID = ""_id""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The row ID.
 * <p>Type: INTEGER</p>
 */
]"
"[TITLE = ""title""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Descriptive name of the bookmark that can be displayed to the user.
 * If this is empty, the title should be resolved at display time (use
 * {@link #getTitle(Context, Cursor)} any time you want to display the
 * title of a bookmark.)
 * <P>
 * Type: TEXT
 * </P>
 */
]"
"[FOLDER = ""folder""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Arbitrary string (displayed to the user) that allows bookmarks to be
 * organized into categories.  There are some special names for
 * standard folders, which all start with '@'.  The label displayed for
 * the folder changes with the locale (via {@link #getLabelForFolder}) but
 * the folder name does not change so you can consistently query for
 * the folder regardless of the current locale.
 *
 * <P>Type: TEXT</P>
 */
]"
"[INTENT = ""intent""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The Intent URL of the bookmark, describing what it points to.  This
 * value is given to {@link android.content.Intent#getIntent} to create
 * an Intent that can be launched.
 * <P>Type: TEXT</P>
 */
]"
"[SHORTCUT = ""shortcut""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * Optional shortcut character associated with this bookmark.
 * <P>Type: INTEGER</P>
 */
]"
"[ORDERING = ""ordering""]","[]","[PUBLIC, STATIC, FINAL]","Optional[/**
 * The order in which the bookmark should be displayed
 * <P>Type: INTEGER</P>
 */
]"
"[sIntentProjection = { INTENT }]","[]","[PRIVATE, STATIC, FINAL]","Optional.empty"
"[sShortcutProjection = { ID, SHORTCUT }]","[]","[PRIVATE, STATIC, FINAL]","Optional.empty"
"[sShortcutSelection = SHORTCUT + ""=?""]","[]","[PRIVATE, STATIC, FINAL]","Optional.empty"
